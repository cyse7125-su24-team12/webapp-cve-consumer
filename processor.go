package main

import (
	"database/sql"
	// "encoding/json"
	"fmt"
	"os"
	// "path/filepath"
	// "strings"
	// "time"
	"github.com/IBM/sarama"
	"log"
)

func checkTopicExists(admin sarama.ClusterAdmin, topic string) (bool, error) {
	topics, err := admin.ListTopics()
	if err != nil {
		return false, err
	}
	_, exists := topics[topic]
	return exists, nil
}

func sendMessageToTopic(brokerList []string, config *sarama.Config) {
	// // Create a new Kafka producer
	producer, err := sarama.NewSyncProducer(brokerList, config)
	if err != nil {
		log.Fatalf("Failed to create producer: %v", err)
	}
	defer producer.Close()

	byteValue, err := os.ReadFile("./CVE-1999-0001.json")
	if err != nil {
		fmt.Println(err)
	}

	// Publish a message
	topic := "cve"
	message := &sarama.ProducerMessage{
		Topic: topic,
		Value: sarama.ByteEncoder(byteValue),
	}
	partition, offset, err := producer.SendMessage(message)
	if err != nil {
		log.Fatalf("Failed to send message: %v", err)
	}
	log.Printf("Message sent to partition %d at offset %d\n", partition, offset)
}

func traverseAndStoreJSONFiles(db *sql.DB) error {
	// Download the file
	brokerList := []string{"cve-kafka.namespace2.svc.cluster.local:9092"}

	// SASL/PLAIN authentication configuration
	config := sarama.NewConfig()
	config.Net.SASL.Enable = true
	config.Net.SASL.Mechanism = sarama.SASLTypePlaintext
	config.Net.SASL.User = "user1"
	config.Net.SASL.Password = "2RyxA0pMwT"
	config.Producer.RequiredAcks = sarama.WaitForAll
	config.Producer.Return.Successes = true

	// Enable debug logging
	sarama.Logger = log.New(os.Stdout, "[sarama] ", log.LstdFlags)

	admin, err := sarama.NewClusterAdmin([]string{"cve-kafka.namespace2.svc.cluster.local:9092"}, config)
	if err != nil {
		log.Fatalf("Failed to create Kafka cluster admin: %s", err)
	}
	defer admin.Close()

	topicExists, err := checkTopicExists(admin, "cve")
	if err != nil {
		log.Fatalf("Failed to check if topic exists: %s", err)
	}

	if topicExists {
		fmt.Print("Topic exists")
	} else {
		// log.Println("Topic does not exist")
		panic("Topic does not exist")
	}

	log.Printf("Sending message to topic")
	sendMessageToTopic(brokerList, config)
	log.Printf("Message sent to topic")
	if err := db.Ping(); err != nil {
		log.Fatalf("Error pinging the database: %v", err)
	}
	consumerMessages(brokerList, config, "cve", db)

	// fmt.Println("Consume messages and store in database...")

	// err := filepath.Walk(basePath, func(path string, info os.FileInfo, err error) error {
	// 	if err != nil {
	// 		return err
	// 	}
	// 	if info.IsDir() {
	// 		return nil
	// 	}

	// 	// Check if the file is a JSON file and not in the list of excluded files
	// 	filename := filepath.Base(path)
	// 	if filepath.Ext(filename) == ".json" && !exclusions[filename] {
	// 		fileCounter++
	// 		data, err := os.ReadFile(path)
	// 		if err != nil {
	// 			return err
	// 		}

	// 		var jsonObj map[string]interface{}
	// 		if err := json.Unmarshal(data, &jsonObj); err != nil {
	// 			return err
	// 		}

	// 		// Use the file name without extension as the cve_id
	// 		cveID := strings.TrimSuffix(filename, filepath.Ext(filename))
	// 		currentDate := getCurrentDate(jsonObj)

	// 		exists, version, err := checkExistingRecord(db, cveID, currentDate)
	// 		if err != nil {
	// 			return err
	// 		}
	// 		if exists {
	// 			fmt.Println("No operation needed, duplicate data.")
	// 			return nil // Duplicate data, do nothing
	// 		}

	// 		if version != 0 {
	// 			version++ // New version of an existing record
	// 		} else {
	// 			version = 1 // New record
	// 		}

	// 		if err := insertJSONData(db, cveID, data, version, currentDate); err != nil {
	// 			return err
	// 		}

	// 		fmt.Printf("%d\n", fileCounter)
	// 	}
	// 	return nil
	// })

	// return
	return nil
}

// func getCurrentDate(jsonObj map[string]interface{}) string {
// 	const layout = "2006-01-02T15:04:05" // Base layout for the current time

// 	if metaData, ok := jsonObj["cveMetadata"].(map[string]interface{}); ok {
// 		if dateStr, ok := metaData["dateUpdated"].(string); ok {
// 			// Find the last colon which precedes the seconds
// 			lastColon := strings.LastIndex(dateStr, ":")
// 			if lastColon != -1 && len(dateStr) > lastColon+3 {
// 				// Trim the string to the format "YYYY-MM-DDTHH:MI:SS"
// 				return dateStr[:lastColon+3]
// 			}
// 			// Return the date string as is if it doesn't match the expected pattern
// 			return dateStr
// 		}
// 	}

// 	// Return the current time formatted to the specified layout, without fractional seconds
// 	return time.Now().Format(layout)
// }
